---
title: "Golang Net Http"
date: 2017-10-25T14:26:52+08:00
draft: true
---

# golang net/http包详解

> net/http 包是进行web和网络编程经常用到的一个包。详细了解golang 标准库里的这个包会对提高网路编程技巧有帮助
* TCP编程
```
func main() {
        l, err := net.Listen("tcp", ":2000")
        if err != nil {
                log.Fatal(err)
        }
        defer l.Close()
        for {
                // Wait for a connection.
                conn, err := l.Accept()
                if err != nil {
                        log.Fatal(err)
                }           
                go func(c net.Conn) {
                        // Echo all incoming data.
                        io.Copy(os.Stdout,c)
                        // Shut down the connection.
                        c.Close()
                }(conn)
        }
}
```

在上面这段代码里面主要有3点

1. Net.liseten() liseten 返回一个listener interface 的实例

2. l.Accept() listener有个Accept方法 Accept方法返回一个net.Conn interface 的实例

3. Conn接口实现了Read(b []byte) (n int, err error)和Write(b []byte) (n int, err error)方法所以Conn的

   实例也是Read类型，在一个goroutine中可以将Conn中的流拷贝到标准输出中

上面的是一个最基本的Tcp编程的例子，http服务也是通过tcp传输的所以一个如果我们定义一个http服务前2步基本相同，不同点是后面得到Conn后我们的处理方式不会这么简单粗暴。

* Http编程

  ​

  * 我们先看看net/http  包中的几个主要的结构和方法

    1. Server 结构
    2. Handler接口

    3. Serve方法
    4. ListenAndServer方法
    5. ListenAndServer函数

  * 使用funcHandle 和 Handle 

    ```
    	http.HandleFunc("/bar", func(w http.ResponseWriter, r *http.Request) {
    		fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))
    	})
    	err:=http.("0.0.0.0:4444",nil)
    	if err!=nil{
    		log.Println(err)
    	}
    ```

    这是一段常见的建立http服务的代码。首先使用了HandleFunc函数把一个handle函数绑定到/bar 这个url上。

    ```
    func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    	DefaultServeMux.HandleFunc(pattern, handler)
    }
    ```

    ```
    var defaultServeMux ServeMux
    var DefaultServeMux = &defaultServeMux
    type ServeMux struct {
    	mu    sync.RWMutex
    	m     map[string]muxEntry
    	hosts bool // whether any patterns contain hostnames
    }
    ```
    DefaultServeMux是ServeMux结构体的一个指针。DefaultServeMux.HandleFunc(pattern, handler)实际上就是调用ServerMux.HandleFunc.注意在HandleFunc中的调用Handle之前调用HandlerFunc将一个函数转出成了Handler类型。这是golang中经常使用到的一种adapter方式。看看HandlerFunc的定义,将HandleFunc定义为一个函数字面量类型然后实现Handler接口的唯一方法ServerHTTP 就可以使用HandleFunc(f)这样的方式将一个函数转化为Handler接口

    ```
    type HandlerFunc func(ResponseWriter, *Request)

    // ServeHTTP calls f(w, r).
    func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    	f(w, r)
    }
    ```

    ​

    ```
    func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    	mux.Handle(pattern, HandlerFunc(handler))
    }
    ```

    ```
    func (mux *ServeMux) Handle(pattern string, handler Handler) {
    	mux.mu.Lock()
    	defer mux.mu.Unlock()

    	if pattern == "" {
    		panic("http: invalid pattern " + pattern)
    	}
    	if handler == nil {
    		panic("http: nil handler")
    	}
    	if mux.m[pattern].explicit {
    		panic("http: multiple registrations for " + pattern)
    	}

    	if mux.m == nil {
    		mux.m = make(map[string]muxEntry)
    	}
    	mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

    	if pattern[0] != '/' {
    		mux.hosts = true
    	}

    	// Helpful behavior:
    	// If pattern is /tree/, insert an implicit permanent redirect for /tree.
    	// It can be overridden by an explicit registration.
    	n := len(pattern)
    	if n > 0 && pattern[n-1] == '/' && !mux.m[pattern[0:n-1]].explicit {
    		// If pattern contains a host name, strip it and use remaining
    		// path for redirect.
    		path := pattern
    		if pattern[0] != '/' {
    			// In pattern, at least the last character is a '/', so
    			// strings.Index can't be -1.
    			path = pattern[strings.Index(pattern, "/"):]
    		}
    		url := &url.URL{Path: path}
    		mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
    	}
    }
    ```

    *ServeMux的 Handle方法首先申请一个读写锁，然后对mux的m元素进行相应的赋值。m的key是pattern value是muxEntry结构体其中包含一个h 为handler类型 parttern为string。

    总结一下HandleFunc的调用过程可以发现最后实际上是对defaultServeMux这个ServeMux结构体的变量进行修改。所以说http.ListenAndServe中肯定用到了defaultServeMux 。下面我们找找看那里用到了defaultServeMux。

    ```
    func ListenAndServe(addr string, handler Handler) error {
    	server := &Server{Addr: addr, Handler: handler}
    	return server.ListenAndServe()
    }

    func (srv *Server) ListenAndServe() error {
    	addr := srv.Addr
    	if addr == "" {
    		addr = ":http"
    	}
    	ln, err := net.Listen("tcp", addr)
    	if err != nil {
    		return err
    	}
    	return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
    }

    func (srv *Server) Serve(l net.Listener) error {
    	defer l.Close()
    	if fn := testHookServerServe; fn != nil {
    		fn(srv, l)
    	}
    	var tempDelay time.Duration // how long to sleep on accept failure

    	if err := srv.setupHTTP2_Serve(); err != nil {
    		return err
    	}

    	srv.trackListener(l, true)
    	defer srv.trackListener(l, false)

    	baseCtx := context.Background() // base is always background, per Issue 16220
    	ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    	ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())
    	for {
    		rw, e := l.Accept()
    		if e != nil {
    			select {
    			case <-srv.getDoneChan():
    				return ErrServerClosed
    			default:
    			}
    			if ne, ok := e.(net.Error); ok && ne.Temporary() {
    				if tempDelay == 0 {
    					tempDelay = 5 * time.Millisecond
    				} else {
    					tempDelay *= 2
    				}
    				if max := 1 * time.Second; tempDelay > max {
    					tempDelay = max
    				}
    				srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)
    				time.Sleep(tempDelay)
    				continue
    			}
    			return e
    		}
    		tempDelay = 0
    		c := srv.newConn(rw)
    		c.setState(c.rwc, StateNew) // before Serve can return
    		go c.serve(ctx)
    	}
    }
    ```

    可以看到最终还收腰调用Server.Serve函数。

    ```
    // Serve accepts incoming connections on the Listener l, creating a
    // new service goroutine for each. The service goroutines read requests and
    // then call srv.Handler to reply to them.
    //
    // For HTTP/2 support, srv.TLSConfig should be initialized to the
    // provided listener's TLS Config before calling Serve. If
    // srv.TLSConfig is non-nil and doesn't include the string "h2" in
    // Config.NextProtos, HTTP/2 support is not enabled.
    //
    // Serve always returns a non-nil error. After Shutdown or Close, the
    // returned error is ErrServerClosed.
    ```

    上面的是Serve方法的注释。在golang的标准库里面有很多库的注释就是我们学习这个库的最好教程。这里写到Serve方法接受一个listenner类型的链接l，然后为每个链接创建一个服务goroutine。每个服务goroutine 读取请求然后调用server的handler应答请求...

    ```
    if fn := testHookServerServe; fn != nil {
    		fn(srv, l)
    	}
    var testHookServerServe func(*Server, net.Listener) // used if non-nil	
    ```

    这个testHookServerServe其实是一个函数类型的变量。定义的时候也没有赋值所以肯定为nil这里我也不知为什么需要这些代码,可能需要的时候直接给其赋值一个函数实现可以灵活处理。

    紧接着调用了setupHTTP2_Serve方法给server配置了http2.关于http2下一篇文章会有详细说明。trackListener跟踪这次链接会将这次链接加入的server中的listenersMap中。

  ​





