<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8" />

  
  <title></title>

  
  




  
  <meta name="author" content="" />
  <meta name="description" content="golang net/http包详解  net/http 包是进行web和网络编程经常用到的一个包。详细了解golang 标准库里的这个包会对提高网路编程技巧有帮助 * TCP编程
func main() { l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:2000&amp;quot;) if err != nil { log.Fatal(err) } defer l.Close() for { // Wait for a connection. conn, err := l.Accept() if err != nil { log.Fatal(err) } go func(c net.Conn) { // Echo all incoming data. io.Copy(os.Stdout,c) // Shut down the connection. c.Close() }(conn) } }   在上面这段代码里面主要有3点
 Net.liseten() liseten 返回一个listener interface 的实例" />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@gohugoio" />
    <meta name="twitter:title" content="" />
    <meta name="twitter:description" content="golang net/http包详解  net/http 包是进行web和网络编程经常用到的一个包。详细了解golang 标准库里的这个包会对提高网路编程技巧有帮助 * TCP编程
func main() { l, err := net.Listen(&amp;quot;tcp&amp;quot;, &amp;quot;:2000&amp;quot;) if err != nil { log.Fatal(err) } defer l.Close() for { // Wait for a connection. conn, err := l.Accept() if err != nil { log.Fatal(err) } go func(c net.Conn) { // Echo all incoming data. io.Copy(os.Stdout,c) // Shut down the connection. c.Close() }(conn) } }   在上面这段代码里面主要有3点
 Net.liseten() liseten 返回一个listener interface 的实例" />
    <meta name="twitter:image" content="https://myonlyzzy.github.io/img/avatar.jpg" />
  




<meta name="generator" content="Hugo 0.24.1" />


<link rel="canonical" href="https://myonlyzzy.github.io/post/golang-net-http/" />
<link rel="alternative" href="/index.xml" title="Myonlyzzy Blog" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Myonlyzzy Blog" />
<meta name="msapplication-tooltip" content="Myonlyzzy Blog" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="/img/touch-icon-apple.png" />
<link rel="mask-icon" href="/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="" alt="Avatar">
  
  <h2 class="title">Myonlyzzy Blog</h2>
  
  <p class="subtitle"></p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item  is-active"><a href="/">Home</a></li>
      
        <li class="menu-item "><a href="https://github.com/myonlyzzy/">Works</a></li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title"></h1>
      <p class="post-meta">@ · Jan 1, 0001 · 4 min read</p>
    </header>
    <article class="post-content">

<h1 id="golang-net-http包详解">golang net/http包详解</h1>

<blockquote>
<p>net/http 包是进行web和网络编程经常用到的一个包。详细了解golang 标准库里的这个包会对提高网路编程技巧有帮助
* TCP编程</p>

<pre><code>func main() {
        l, err := net.Listen(&quot;tcp&quot;, &quot;:2000&quot;)
        if err != nil {
                log.Fatal(err)
        }
        defer l.Close()
        for {
                // Wait for a connection.
                conn, err := l.Accept()
                if err != nil {
                        log.Fatal(err)
                }           
                go func(c net.Conn) {
                        // Echo all incoming data.
                        io.Copy(os.Stdout,c)
                        // Shut down the connection.
                        c.Close()
                }(conn)
        }
}
</code></pre>
</blockquote>

<p>在上面这段代码里面主要有3点</p>

<ol>
<li><p>Net.liseten() liseten 返回一个listener interface 的实例</p></li>

<li><p>l.Accept() listener有个Accept方法 Accept方法返回一个net.Conn interface 的实例</p></li>

<li><p>Conn接口实现了Read(b []byte) (n int, err error)和Write(b []byte) (n int, err error)方法所以Conn的</p></li>
</ol>

<p>实例也是Read类型，在一个goroutine中可以将Conn中的流拷贝到标准输出中</p>

<p>上面的是一个最基本的Tcp编程的例子，http服务也是通过tcp传输的所以一个如果我们定义一个http服务前2步基本相同，不同点是后面得到Conn后我们的处理方式不会这么简单粗暴。</p>

<ul>
<li>Http编程</li>
</ul>

<p>​</p>

<ul>
<li><p>我们先看看net/http  包中的几个主要的结构和方法</p>

<ol>
<li>Server 结构</li>

<li><p>Handler接口</p></li>

<li><p>Serve方法</p></li>

<li><p>ListenAndServer方法</p></li>

<li><p>ListenAndServer函数</p></li>
</ol></li>

<li><p>使用funcHandle 和 Handle</p>

<pre><code>    http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))
    })
    err:=http.(&quot;0.0.0.0:4444&quot;,nil)
    if err!=nil{
        log.Println(err)
    }
</code></pre>

<p>这是一段常见的建立http服务的代码。首先使用了HandleFunc函数把一个handle函数绑定到/bar 这个url上。</p>

<pre><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>

<pre><code>var defaultServeMux ServeMux
var DefaultServeMux = &amp;defaultServeMux
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    hosts bool // whether any patterns contain hostnames
}
</code></pre>

<p>DefaultServeMux是ServeMux结构体的一个指针。DefaultServeMux.HandleFunc(pattern, handler)实际上就是调用ServerMux.HandleFunc.注意在HandleFunc中的调用Handle之前调用HandlerFunc将一个函数转出成了Handler类型。这是golang中经常使用到的一种adapter方式。看看HandlerFunc的定义,将HandleFunc定义为一个函数字面量类型然后实现Handler接口的唯一方法ServerHTTP 就可以使用HandleFunc(f)这样的方式将一个函数转化为Handler接口</p>

<pre><code>type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre>

<p>​</p>

<pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>

<pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()

    if pattern == &quot;&quot; {
        panic(&quot;http: invalid pattern &quot; + pattern)
    }
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    if mux.m[pattern].explicit {
        panic(&quot;http: multiple registrations for &quot; + pattern)
    }

    if mux.m == nil {
        mux.m = make(map[string]muxEntry)
    }
    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

    if pattern[0] != '/' {
        mux.hosts = true
    }

    // Helpful behavior:
    // If pattern is /tree/, insert an implicit permanent redirect for /tree.
    // It can be overridden by an explicit registration.
    n := len(pattern)
    if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit {
        // If pattern contains a host name, strip it and use remaining
        // path for redirect.
        path := pattern
        if pattern[0] != '/' {
            // In pattern, at least the last character is a '/', so
            // strings.Index can't be -1.
            path = pattern[strings.Index(pattern, &quot;/&quot;):]
        }
        url := &amp;url.URL{Path: path}
        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
    }
}
</code></pre>

<p>*ServeMux的 Handle方法首先申请一个读写锁，然后对mux的m元素进行相应的赋值。m的key是pattern value是muxEntry结构体其中包含一个h 为handler类型 parttern为string。</p>

<p>总结一下HandleFunc的调用过程可以发现最后实际上是对defaultServeMux这个ServeMux结构体的变量进行修改。所以说http.ListenAndServe中肯定用到了defaultServeMux 。下面我们找找看那里用到了defaultServeMux。</p>

<pre><code>func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}

func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}

func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
    var tempDelay time.Duration // how long to sleep on accept failure

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    srv.trackListener(l, true)
    defer srv.trackListener(l, false)

    baseCtx := context.Background() // base is always background, per Issue 16220
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}
</code></pre>

<p>可以看到最终还收腰调用Server.Serve函数。</p>

<pre><code>// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// For HTTP/2 support, srv.TLSConfig should be initialized to the
// provided listener's TLS Config before calling Serve. If
// srv.TLSConfig is non-nil and doesn't include the string &quot;h2&quot; in
// Config.NextProtos, HTTP/2 support is not enabled.
//
// Serve always returns a non-nil error. After Shutdown or Close, the
// returned error is ErrServerClosed.
</code></pre>

<p>上面的是Serve方法的注释。在golang的标准库里面有很多库的注释就是我们学习这个库的最好教程。这里写到Serve方法接受一个listenner类型的链接l，然后为每个链接创建一个服务goroutine。每个服务goroutine 读取请求然后调用server的handler应答请求&hellip;</p>

<pre><code>if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
var testHookServerServe func(*Server, net.Listener) // used if non-nil  
</code></pre>

<p>这个testHookServerServe其实是一个函数类型的变量。定义的时候也没有赋值所以肯定为nil这里我也不知为什么需要这些代码,可能需要的时候直接给其赋值一个函数实现可以灵活处理。</p>

<p>紧接着调用了setupHTTP2_Serve方法给server配置了http2.关于http2下一篇文章会有详细说明。trackListener跟踪这次链接会将这次链接加入的server中的listenersMap中。</p></li>
</ul>

<p>​</p>
</article>
    <footer class="post-footer">
      
      <p class="post-copyright">
        This post was published <strong>736626</strong> days ago, content in the post may be inaccurate, even wrong now, please take risk yourself.
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017 Myonlyzzy Blog</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[','\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>

<script src="/js/bundle.js"></script>




  </body>
</html>
