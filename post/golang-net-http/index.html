<!doctype html>
<html lang="en-us">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.53" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Golang Net Http | Myonlyzzy Blog</title>
    <meta property="og:title" content="Golang Net Http - Myonlyzzy Blog">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content="2017-10-25T14:26:52&#43;08:00">
        
        
    <meta property="article:modified_time" content="2017-10-25T14:26:52&#43;08:00">
        
    <meta name="Keywords" content="golang,go语言,kubernetes,容器,docker,k8s">
    <meta name="description" content="Golang Net Http">
        
    <meta name="author" content="myonlyzzy">
    <meta property="og:url" content="https://myonlyzzy.github.io/post/golang-net-http/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
        <link rel="stylesheet" href="/css/prism.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

    


    
    
</head>

<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://myonlyzzy.github.io">
                        Myonlyzzy Blog
                    </a>
                
                <p class="description">专注与golang k8s</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://myonlyzzy.github.io">首页</a>
                    
                    <a  href="https://myonlyzzy.github.io/" title="Home">Home</a>
                    
                    <a  href="https://myonlyzzy.github.io/about/" title="关于">关于</a>
                    
                    <a  href="https://myonlyzzy.github.io/works/" title="工作">工作</a>
                    
                    <a  href="https://myonlyzzy.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://myonlyzzy.github.io/about/" title="About">About</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    <article class="post">
                        <header>
                            <h1 class="post-title">Golang Net Http</h1>
                        </header>
                        <date class="post-meta meta-date">
                            2017年10月25日
                        </date>
                        
                        
                        <div class="post-content">
                            

<h1 id="golang-net-http包详解">golang net/http包详解</h1>

<blockquote>
<p>net/http 包是进行web和网络编程经常用到的一个包。详细了解golang 标准库里的这个包会对提高网路编程技巧有帮助
* TCP编程</p>

<pre><code>func main() {
        l, err := net.Listen(&quot;tcp&quot;, &quot;:2000&quot;)
        if err != nil {
                log.Fatal(err)
        }
        defer l.Close()
        for {
                // Wait for a connection.
                conn, err := l.Accept()
                if err != nil {
                        log.Fatal(err)
                }           
                go func(c net.Conn) {
                        // Echo all incoming data.
                        io.Copy(os.Stdout,c)
                        // Shut down the connection.
                        c.Close()
                }(conn)
        }
}
</code></pre>
</blockquote>

<p>在上面这段代码里面主要有3点</p>

<ol>
<li><p>Net.liseten() liseten 返回一个listener interface 的实例</p></li>

<li><p>l.Accept() listener有个Accept方法 Accept方法返回一个net.Conn interface 的实例</p></li>

<li><p>Conn接口实现了Read(b []byte) (n int, err error)和Write(b []byte) (n int, err error)方法所以Conn的</p></li>
</ol>

<p>实例也是Read类型，在一个goroutine中可以将Conn中的流拷贝到标准输出中</p>

<p>上面的是一个最基本的Tcp编程的例子，http服务也是通过tcp传输的所以一个如果我们定义一个http服务前2步基本相同，不同点是后面得到Conn后我们的处理方式不会这么简单粗暴。</p>

<ul>
<li>Http编程</li>
</ul>

<p>​</p>

<ul>
<li><p>我们先看看net/http  包中的几个主要的结构和方法</p>

<ol>
<li>Server 结构</li>

<li><p>Handler接口</p></li>

<li><p>Serve方法</p></li>

<li><p>ListenAndServer方法</p></li>

<li><p>ListenAndServer函数</p></li>
</ol></li>

<li><p>使用funcHandle 和 Handle</p>

<pre><code>    http.HandleFunc(&quot;/bar&quot;, func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, &quot;Hello, %q&quot;, html.EscapeString(r.URL.Path))
    })
    err:=http.(&quot;0.0.0.0:4444&quot;,nil)
    if err!=nil{
        log.Println(err)
    }
</code></pre>

<p>这是一段常见的建立http服务的代码。首先使用了HandleFunc函数把一个handle函数绑定到/bar 这个url上。</p>

<pre><code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
</code></pre>

<pre><code>var defaultServeMux ServeMux
var DefaultServeMux = &amp;defaultServeMux
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    hosts bool // whether any patterns contain hostnames
}
</code></pre>

<p>DefaultServeMux是ServeMux结构体的一个指针。DefaultServeMux.HandleFunc(pattern, handler)实际上就是调用ServerMux.HandleFunc.注意在HandleFunc中的调用Handle之前调用HandlerFunc将一个函数转出成了Handler类型。这是golang中经常使用到的一种adapter方式。看看HandlerFunc的定义,将HandleFunc定义为一个函数字面量类型然后实现Handler接口的唯一方法ServerHTTP 就可以使用HandleFunc(f)这样的方式将一个函数转化为Handler接口</p>

<pre><code>type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre>

<p>​</p>

<pre><code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
</code></pre>

<pre><code>func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()

    if pattern == &quot;&quot; {
        panic(&quot;http: invalid pattern &quot; + pattern)
    }
    if handler == nil {
        panic(&quot;http: nil handler&quot;)
    }
    if mux.m[pattern].explicit {
        panic(&quot;http: multiple registrations for &quot; + pattern)
    }

    if mux.m == nil {
        mux.m = make(map[string]muxEntry)
    }
    mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern}

    if pattern[0] != '/' {
        mux.hosts = true
    }

    // Helpful behavior:
    // If pattern is /tree/, insert an implicit permanent redirect for /tree.
    // It can be overridden by an explicit registration.
    n := len(pattern)
    if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit {
        // If pattern contains a host name, strip it and use remaining
        // path for redirect.
        path := pattern
        if pattern[0] != '/' {
            // In pattern, at least the last character is a '/', so
            // strings.Index can't be -1.
            path = pattern[strings.Index(pattern, &quot;/&quot;):]
        }
        url := &amp;url.URL{Path: path}
        mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern}
    }
}
</code></pre>

<p>*ServeMux的 Handle方法首先申请一个读写锁，然后对mux的m元素进行相应的赋值。m的key是pattern value是muxEntry结构体其中包含一个h 为handler类型 parttern为string。</p>

<p>总结一下HandleFunc的调用过程可以发现最后实际上是对defaultServeMux这个ServeMux结构体的变量进行修改。所以说http.ListenAndServe中肯定用到了defaultServeMux 。下面我们找找看那里用到了defaultServeMux。</p>

<pre><code>func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}

func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}

func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
    var tempDelay time.Duration // how long to sleep on accept failure

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    srv.trackListener(l, true)
    defer srv.trackListener(l, false)

    baseCtx := context.Background() // base is always background, per Issue 16220
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    ctx = context.WithValue(ctx, LocalAddrContextKey, l.Addr())
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}
</code></pre>

<p>可以看到最终还收腰调用Server.Serve函数。</p>

<pre><code>// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each. The service goroutines read requests and
// then call srv.Handler to reply to them.
//
// For HTTP/2 support, srv.TLSConfig should be initialized to the
// provided listener's TLS Config before calling Serve. If
// srv.TLSConfig is non-nil and doesn't include the string &quot;h2&quot; in
// Config.NextProtos, HTTP/2 support is not enabled.
//
// Serve always returns a non-nil error. After Shutdown or Close, the
// returned error is ErrServerClosed.
</code></pre>

<p>上面的是Serve方法的注释。在golang的标准库里面有很多库的注释就是我们学习这个库的最好教程。这里写到Serve方法接受一个listenner类型的链接l，然后为每个链接创建一个服务goroutine。每个服务goroutine 读取请求然后调用server的handler应答请求&hellip;</p>

<pre><code>if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
var testHookServerServe func(*Server, net.Listener) // used if non-nil  
</code></pre>

<p>这个testHookServerServe其实是一个函数类型的变量。定义的时候也没有赋值所以肯定为nil这里我也不知为什么需要这些代码,可能需要的时候直接给其赋值一个函数实现可以灵活处理。</p>

<p>紧接着调用了setupHTTP2_Serve方法给server配置了http2.关于http2下一篇文章会有详细说明。trackListener跟踪这次链接会将这次链接加入的server中的listenersMap中。</p></li>
</ul>

<p>​</p>

                        </div>

                        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/about/">About</a></li>
        
        <li><a href="/post/http2grpc/"></a></li>
        
        <li><a href="/post/k8s-ingress/">ks8 ingress</a></li>
        
        <li><a href="/post/istio/"></a></li>
        
        <li><a href="/post/tidb-tip/"></a></li>
        
    </ul>
</div>


                        <div class="post-meta meta-tags">
                            
                            没有标签
                            
                        </div>
                    </article>
                    
    

    
    
                </div>
            </div>
            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://myonlyzzy.github.io">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://myonlyzzy.github.io/post/docker-proxy/" title="Docker Proxy">Docker Proxy</a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/kingshard/" title="Docker Proxy">Docker Proxy</a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/golang-net-http/" title="Golang Net Http">Golang Net Http</a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/grpc-guides/" title=""></a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/http2grpc/" title=""></a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/istio/" title=""></a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/tidb-tip/" title=""></a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/golang-sync-pool/" title="golang-sync-Pool">golang-sync-Pool</a>
    </li>
    
    <li>
        <a href="https://myonlyzzy.github.io/post/k8s-ingress/" title="ks8 ingress">ks8 ingress</a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://golang.org/" title="golang官网">golang官网</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://myonlyzzy.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2018 <a href="https://myonlyzzy.github.io">Myonlyzzy Blog By myonlyzzy</a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="http://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>


    <script type="text/javascript">
    
    (function(){
        $("pre code").parent().addClass("line-numbers")
    }())

    window.MathJax = {
        tex2jax: {
            inlineMath: [ ['$','$'] ],
            processEscapes: true
        }
    };
    </script>
    <script type="text/javascript" src="/js/prism.js" async="true"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>






</body>
</html>
